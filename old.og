package main

import (
	"bytes"
	"context"
	"crypto/rand"
	// "encoding/json"
	"flag"
	"fmt"
	"io"
	"io/ioutil"
	"log"
	"math"
	mrand "math/rand"
	"net"
	"net/http"
	// "net/url"
	"os"
	"os/signal"
	// "strconv"
	"strings"
	"syscall"
	"time"

	"github.com/ad/gocc/proto"

	"github.com/kardianos/osext"
	"github.com/lixiangzhong/traceroute"
	"github.com/tevino/abool"
	"google.golang.org/grpc"

	// "github.com/blang/semver"
	"github.com/bogdanovich/dns_resolver"
	// "github.com/gorilla/websocket"
	uuid "github.com/nu7hatch/gouuid"
	// "github.com/rhysd/go-github-selfupdate/selfupdate"
	"github.com/tatsushid/go-fastping"

	crypto "github.com/libp2p/go-libp2p-core/crypto"
	// network "github.com/libp2p/go-libp2p-core/network"
	csms "github.com/libp2p/go-conn-security-multistream"
	host "github.com/libp2p/go-libp2p-host"
	peer "github.com/libp2p/go-libp2p-peer"
	pstore "github.com/libp2p/go-libp2p-peerstore/pstoremem"
	swarm "github.com/libp2p/go-libp2p-swarm"
	tptu "github.com/libp2p/go-libp2p-transport-upgrader"
	yamux "github.com/libp2p/go-libp2p-yamux"
	bhost "github.com/libp2p/go-libp2p/p2p/host/basic"
	msmux "github.com/libp2p/go-stream-muxer-multistream"
	tcp "github.com/libp2p/go-tcp-transport"
	ma "github.com/multiformats/go-multiaddr"
	p2pgrpc "github.com/paralin/go-libp2p-grpc"
)

func lookupEnvOrString(key string, defaultVal string) string {
	if val, ok := os.LookupEnv(key); ok {
		return val
	}
	return defaultVal
}

// func lookupEnvOrInt(key string, defaultVal int) int {
// 	if val, ok := os.LookupEnv(key); ok {
// 		v, err := strconv.Atoi(val)
// 		if err != nil {
// 			log.Fatalf("lookupEnvOrInt[%s]: %v", key, err)
// 		}
// 		return v
// 	}
// 	return defaultVal
// }

// GenUpgrader creates a new connection upgrader for use with this swarm.
func GenUpgrader(n *swarm.Swarm) *tptu.Upgrader {
	// id := n.LocalPeer()
	// pk := n.Peerstore().PrivKey(id)
	secMuxer := new(csms.SSMuxer)
	// secMuxer.AddTransport(secio.ID, &secio.Transport{
	// 	LocalID:    id,
	// 	PrivateKey: pk,
	// })

	stMuxer := msmux.NewBlankTransport()
	stMuxer.AddTransport("/yamux/1.0.0", yamux.DefaultTransport)

	return &tptu.Upgrader{
		Secure:  secMuxer,
		Muxer:   stMuxer,
		Filters: n.Filters,
	}

}

// makeBasicHost creates a LibP2P host with a random peer ID listening on the given multiaddress
func makeBasicHost(privKey, pubKey, listenAddr string, randseed int) (host.Host, error) {
	var err error

	privBytes, err := ioutil.ReadFile(privKey)
	if err != nil {
		log.Fatal(err)
	}

	pubBytes, err := ioutil.ReadFile(pubKey)
	if err != nil {
		log.Fatal(err)
	}

	var priv crypto.PrivKey
	var pub crypto.PubKey

	if privBytes != nil || pubBytes != nil {
		priv, err = crypto.UnmarshalPrivateKey(privBytes)
		if err != nil {
			log.Fatal(err)
		}
		pub, err = crypto.UnmarshalPublicKey(pubBytes)
		if err != nil {
			log.Fatal(err)
		}
	} else {
		var r io.Reader
		// if randseed == 0 {
		r = rand.Reader
		// } else {
		// r = mrand.New(mrand.NewSource(randseed))
		// }

		// Generate a key pair for this host. We will use it at least
		// to obtain a valid host ID.
		priv, pub, err = crypto.GenerateKeyPairWithReader(crypto.RSA, 2048, r)
		if err != nil {
			return nil, err
		}

		privBytes, err = crypto.MarshalPrivateKey(priv)
		if err != nil {
			log.Fatal(err)
		}

		// _, _ = os.Create(privKey)
		err = ioutil.WriteFile(privKey, privBytes, 0644)
		if err != nil {
			log.Fatalf("error on write file %s: %s", privKey, err)
		}

		pubBytes, err = crypto.MarshalPublicKey(pub)
		if err != nil {
			log.Fatal(err)
		}

		// _, _ = os.Create(pubKey)
		err = ioutil.WriteFile(pubKey, pubBytes, 0644)
		if err != nil {
			log.Fatal(err)
		}
	}
	// }

	// Obtain Peer ID from public key
	pid, err := peer.IDFromPublicKey(pub)
	if err != nil {
		return nil, err
	}

	// Create a multiaddress
	addr, err := ma.NewMultiaddr(listenAddr)
	if err != nil {
		return nil, err
	}

	// Create a peerstore
	ps := pstore.NewPeerstore()

	// Set up stream multiplexer
	// tpt := msmux.NewBlankTransport()
	// tpt.AddTransport("/yamux/1.0.0", yamux.DefaultTransport)

	// Create swarm (implements libP2P Network)
	swrm := swarm.NewSwarm(
		context.Background(),
		pid,
		ps,
		nil)

	tcpTransport := tcp.NewTCPTransport(GenUpgrader(swrm))
	// tcpTransport.DisableReuseport = cfg.disableReuseport

	if err := swrm.AddTransport(tcpTransport); err != nil {
		log.Fatal(err)
	}

	// // swrm, err := swarm.NewSwarmWithProtector(
	// 	context.Background(),
	// 	[]ma.Multiaddr{addr},
	// 	pid,
	// 	nil, //ps,
	// 	nil,
	// 	tpt,
	// 	nil,
	// )
	// if err != nil {
	// 	return nil, err
	// }

	// netw := (*network.Network)(swrm)
	basicHost := bhost.New(swrm)

	// Build host multiaddress
	hostAddr, _ := ma.NewMultiaddr(fmt.Sprintf("/ipfs/%s", basicHost.ID().Pretty()))

	// Now we can build a full multiaddress to reach this host
	// by encapsulating both addresses:
	fullAddr := addr.Encapsulate(hostAddr)
	log.Printf("I am %s\n", fullAddr)
	// log.Printf("Now run \"./echo -l %d -d %s\" on a different terminal\n", listenPort+1, fullAddr)

	return basicHost, nil
}

const version = "0.2.0"

var pongStarted = abool.New()

// func selfUpdate(slug string) error {
// 	previous := semver.MustParse(version)
// 	latest, err := selfupdate.UpdateSelf(previous, slug)
// 	if err != nil {
// 		return err
// 	}

// 	if !previous.Equals(latest.Version) {
// 		fmt.Println("Update successfully done to version", latest.Version)

// 		Restart()
// 	}

// 	return nil
// }

var zu, _ = uuid.NewV4()

// var addr = flag.String("addr", "localhost:80", "cc address:port")

// var grpclistenaddr = flag.String("grpclistenaddr", "localhost:8080", "grpc listen address:port")
var zonduuid = flag.String("uuid", zu.String(), "zond uuid")
var goccAddr string
var listenAddr string

var resolverAddress = flag.String("resolver", "8.8.8.8", "resolver address")

var seed = flag.Int("seed", 0, "set random seed for id generation")

var privKey string
var pubKey string

// Action struct
type Action struct {
	ZondUUID string `json:"zond"`
	Action   string `json:"action"`
	Param    string `json:"param"`
	Result   string `json:"result"`
	UUID     string `json:"uuid"`
}

type srv struct {
	PeerID peer.ID
}

func main() {
	flag.StringVar(&privKey, "privKey", lookupEnvOrString("PRIVKEY", privKey), "privKey")
	flag.StringVar(&pubKey, "pubKey", lookupEnvOrString("PUBKEY", pubKey), "pubKey")
	flag.StringVar(&goccAddr, "gocc", lookupEnvOrString("GOCC", goccAddr), "cc address")
	flag.StringVar(&listenAddr, "listenAddr", lookupEnvOrString("LISTENADDR", listenAddr), "listen address")

	flag.Parse()
	log.SetFlags(0)

	// _ = initGRPC()

	log.Printf("Started version %s", version)

	// ticker := time.NewTicker(10 * time.Minute)
	// go func(ticker *time.Ticker) {
	// 	for {
	// 		select {
	// 		case <-ticker.C:
	// 			if err := selfUpdate("ad/gozond"); err != nil {
	// 				fmt.Fprintln(os.Stderr, err)
	// 			}
	// 		}
	// 	}
	// }(ticker)

	interrupt := make(chan os.Signal, 1)
	signal.Notify(interrupt, os.Interrupt)

	// u := url.URL{Scheme: "ws", Host: *addr, Path: "/sub/tasks,zond" + *zonduuid}
	// log.Printf("connecting to %s", u.String())

	// ws, _, err := websocket.DefaultDialer.Dial(u.String(), http.Header{"X-ZondUuid": {*zonduuid}})
	// if ws != nil {
	// 	defer ws.Close()
	// }
	// if err != nil {
	// 	log.Fatal("dial:", err)
	// }
	// done := make(chan struct{})

	// go func() {
	// 	defer close(done)
	// 	for {
	// 		_, message, err := ws.ReadMessage()
	// 		if err != nil {
	// 			log.Println("read error:", err)
	// 			time.Sleep(time.Duration(rand.Intn(5)) * time.Second)

	// 			Restart()

	// 			return
	// 		}

	// 		var action = new(Action)
	// 		err = json.Unmarshal(message, &action)
	// 		if err != nil {
	// 			fmt.Println("unmarshal error:", err)
	// 		} else {
	// 			if action.Action != "alive" {
	// 				fmt.Printf("%+v\n", action)
	// 			}

	// 			if action.Action == "ping" {
	// 				pingCheck(action.Param, action.UUID)
	// 			} else if action.Action == "head" {
	// 				headCheck(action.Param, action.UUID)
	// 			} else if action.Action == "dns" {
	// 				dnsCheck(action.Param, action.UUID)
	// 			} else if action.Action == "traceroute" {
	// 				tracerouteCheck(action.Param, action.UUID)
	// 			} else if action.Action == "alive" {
	// 				if !pongStarted.IsSet() {
	// 					pongStarted.Set()

	// 					action.ZondUUID = *zonduuid
	// 					js, _ := json.Marshal(action)

	// 					Post("http://"+*addr+"/zond/pong", string(js))

	// 					pongStarted.UnSet()
	// 				}
	// 			}
	// 		}
	// 	}
	// }()

	// for {
	// 	select {
	// 	case <-done:
	// 		return
	// 	case <-interrupt:
	// 		log.Println("interrupt")
	// 		err := ws.WriteMessage(websocket.CloseMessage, websocket.FormatCloseMessage(websocket.CloseNormalClosure, ""))
	// 		if err != nil {
	// 			log.Println("write close error:", err)
	// 			return
	// 		}
	// 		select {
	// 		case <-done:
	// 		case <-time.After(time.Second):
	// 		}
	// 		return
	// 	}
	// }

	// Make a host that listens on the given multiaddress
	ha, err := makeBasicHost(privKey, pubKey, listenAddr, *seed)
	if err != nil {
		log.Fatal(err)
	}

	// Set the grpc protocol handler on it
	grpcProto := p2pgrpc.NewGRPCProtocol(context.Background(), ha)

	// Register our echoer GRPC service.
	proto.RegisterActionServer(grpcProto.GetGRPCServer(), &srv{PeerID: ha.ID()})

	// The following code extracts target's the peer ID from the
	// given multiaddress
	ipfsaddr, err := ma.NewMultiaddr(goccAddr)
	if err != nil {
		log.Fatalln(err)
	}

	pid, err := ipfsaddr.ValueForProtocol(ma.P_IPFS)
	if err != nil {
		log.Fatalln(err)
	}

	peerid, err := peer.IDB58Decode(pid)
	if err != nil {
		log.Fatalln(err)
	}

	// Decapsulate the /ipfs/<peerID> part from the target
	// /ip4/<a.b.c.d>/ipfs/<peer> becomes /ip4/<a.b.c.d>
	targetPeerAddr, _ := ma.NewMultiaddr(
		fmt.Sprintf("/ipfs/%s", peer.IDB58Encode(peerid)))
	targetAddr := ipfsaddr.Decapsulate(targetPeerAddr)

	// We have a peer ID and a targetAddr so we add it to the peerstore
	// so LibP2P knows how to contact it
	ha.Peerstore().AddAddr(peerid, targetAddr, math.MaxInt64-1)

	time.Sleep(1 * time.Second)
	// make a new stream from host B to host A
	log.Println("dialing via grpc")
	grpcConn, err := grpcProto.Dial(context.Background(), peerid, grpc.WithInsecure(), grpc.WithBlock())
	log.Println("0")
	if err != nil {
		log.Fatalln(err)
	}

	log.Println("1")
	// create our service client
	actionClient := proto.NewActionClient(grpcConn)
	log.Println("2")
	actionReply, err := actionClient.Call(context.Background(), &proto.CallRequest{Action: "test"})
	log.Println("3")
	if err != nil {
		log.Fatalln(err)
	}
	log.Println("4")

	log.Printf("read reply: %+v", actionReply)

	log.Println()
	// create our service client
	// echoClient
	// _ = proto.NewActionClient(grpcConn)
	// echoReply, err := echoClient.Echo(context.Background(), &gocc_svc.CallRequest{Message: *echoMsg})
	// if err != nil {
	// 	log.Fatalln(err)
	// }

	// log.Println("read reply:")
	// err = (&jsonpb.Marshaler{EmitDefaults: true, Indent: "\t"}).
	// 	Marshal(os.Stdout, echoReply)
	// if err != nil {
	// 	log.Fatalln(err)
	// }
	// log.Println()
}

// Restart app
func Restart() error {
	file, error := osext.Executable()
	if error != nil {
		return error
	}

	error = syscall.Exec(file, os.Args, os.Environ())
	if error != nil {
		return error
	}

	return nil
}

func blockTask(taskuuid string) (status string) {
	// var action = Action{ZondUUID: *zonduuid, Action: "block", Result: "", UUID: taskuuid}
	// var js, _ = json.Marshal(action)
	status = "" //Post("http://"+*addr+"/zond/task/block", string(js))

	return status
}

func resultTask(taskuuid string, result string) (status string) {
	// var action = Action{ZondUUID: *zonduuid, Action: "result", Result: result, UUID: taskuuid}
	// var js, _ = json.Marshal(action)
	status = "" //Post("http://"+*addr+"/zond/task/result", string(js))

	return status
}

func pingCheck(address string, taskuuid string) {
	var status = blockTask(taskuuid)

	if status != `{"status": "ok", "message": "ok"}` {
		if status == `{"status": "error", "message": "only one task at time is allowed"}` {
			time.Sleep(time.Duration(mrand.Intn(10000)) * time.Millisecond)
			pingCheck(address, taskuuid)
		} else if status != `{"status": "error", "message": "task not found"}` {
			log.Println(taskuuid, status)
		}
	} else {
		p := fastping.NewPinger()
		ra, err := net.ResolveIPAddr("ip4:icmp", address)
		if err != nil {
			fmt.Println(address+" ping failed: ", err)

			resultTask(taskuuid, fmt.Sprintf("failed: %s", err))
		} else {
			p.AddIPAddr(ra)
			var received = false
			p.OnRecv = func(addr *net.IPAddr, rtt time.Duration) {
				received = true
				fmt.Printf("IP Addr: %s receive, RTT: %v\n", addr.String(), rtt)

				resultTask(taskuuid, rtt.String())
			}
			p.OnIdle = func() {
				if !received {
					fmt.Println(address + " ping failed")

					resultTask(taskuuid, "failed")
				}
			}
			err = p.Run()
			if err != nil {
				fmt.Println("Error", err)
			}
		}
	}
}

func dnsCheck(address string, taskuuid string) {
	var status = blockTask(taskuuid)

	if status != `{"status": "ok", "message": "ok"}` {
		if status == `{"status": "error", "message": "only one task at time is allowed"}` {
			time.Sleep(time.Duration(mrand.Intn(10)) * time.Second)
			dnsCheck(address, taskuuid)
		} else if status != `{"status": "error", "message": "task not found"}` {
			log.Println(taskuuid, status)
		}
	} else {
		// var resolverAddress = "8.8.8.8"
		if strings.Count(address, "-") == 1 {
			s := strings.Split(address, "-")
			address, *resolverAddress = s[0], s[1]
		}
		resolver := dns_resolver.New([]string{*resolverAddress})
		// resolver := dns_resolver.NewFromResolvConf("resolv.conf")
		resolver.RetryTimes = 5

		ips, err := resolver.LookupHost(address)

		if err != nil {
			log.Println(address+" dns failed: ", err)

			resultTask(taskuuid, fmt.Sprintf("failed: %s", err))
		} else {
			var s []string
			for _, ip := range ips {
				s = append(s, ip.String())
			}
			var res = strings.Join(s[:], ",")
			log.Printf("IPS: %v", res)

			resultTask(taskuuid, res)
		}
	}
}

func tracerouteCheck(address string, taskuuid string) error {
	var status = blockTask(taskuuid)

	if status != `{"status": "ok", "message": "ok"}` {
		if status == `{"status": "error", "message": "only one task at time is allowed"}` {
			time.Sleep(time.Duration(mrand.Intn(10)) * time.Second)
			return tracerouteCheck(address, taskuuid)
		} else if status != `{"status": "error", "message": "task not found"}` {
			log.Println(taskuuid, status)
			return nil
		}
	} else {
		t := traceroute.New(address)
		//t.MaxTTL=30
		//t.Timeout=3 * time.Second
		//t.LocalAddr="0.0.0.0"
		result, err := t.Do()

		if err != nil {
			resultTask(taskuuid, fmt.Sprintf("failed: %s", err))

			return fmt.Errorf(address+" traceroute failed: ", err)
		}

		var s []string

		for _, v := range result {
			s = append(s, v.String())
		}

		var res = strings.Join(s[:], "\n")
		log.Printf("Result: %v", res)

		resultTask(taskuuid, res)

	}
	return nil
}

func headCheck(address string, taskuuid string) {
	var status = blockTask(taskuuid)

	if status != `{"status": "ok", "message": "ok"}` {
		if status == `{"status": "error", "message": "only one task at time is allowed"}` {
			time.Sleep(time.Duration(mrand.Intn(10)) * time.Second)
			headCheck(address, taskuuid)
		} else if status != `{"status": "error", "message": "task not found"}` {
			log.Println(taskuuid, status)
		}
	} else {
		resp, err := http.Head(address)
		if resp != nil {
			defer resp.Body.Close()
		}
		if err != nil {
			log.Println(address+" http head failed: ", err)

			resultTask(taskuuid, fmt.Sprintf("failed: %s", err))
		} else {
			headers := resp.Header
			var res string
			for key, val := range headers {
				res += fmt.Sprintf("%s: %s\n", key, val)
			}
			log.Printf("Headers: %v", res)

			resultTask(taskuuid, res)
		}
	}
}

// Get request and return response
func Get(url string) string {
	resp, err := http.Get(url)
	if resp != nil {
		defer resp.Body.Close()
	}
	if err == nil {
		contents, err := ioutil.ReadAll(resp.Body)
		if err != nil {
			os.Exit(1)
		}
		return string(contents)
	}
	return "error"
}

// Post request with headers and return response
func Post(url string, jsonData string) string {
	var jsonStr = []byte(jsonData)

	req, err := http.NewRequest("POST", url, bytes.NewBuffer(jsonStr))
	req.Header.Set("Content-Type", "application/json")
	req.Header.Set("X-ZondUuid", *zonduuid)

	client := &http.Client{}
	resp, err := client.Do(req)
	if resp != nil {
		defer resp.Body.Close()
	}
	if err != nil {
		return "error"
	}

	if resp.StatusCode == 429 {
		log.Printf("%s: %d", url, resp.StatusCode)
		time.Sleep(time.Duration(mrand.Intn(30)) * time.Second)
		return Post(url, jsonData)
	}
	body, _ := ioutil.ReadAll(resp.Body)
	return string(body)
}

// func initGRPC() error {
// 	grpcSrv := grpc.NewServer()

// 	GRPCListener, err := net.Listen("tcp", *grpclistenaddr)
// 	if err != nil {
// 		return fmt.Errorf("failed to listen on the TCP network address %s, %s", *grpclistenaddr, err)
// 	}

// 	grpcServer := &srv{}
// 	proto.RegisterActionServer(grpcSrv, grpcServer)

// 	go func() {
// 		if err := grpcSrv.Serve(GRPCListener); err != nil {
// 			log.Println(fmt.Errorf("failed to serve grpc: %s", err))
// 		}
// 	}()

// 	return nil
// }

func (s *srv) Call(ctx context.Context, req *proto.CallRequest) (*proto.CallResponse, error) {
	result := "error"

	if req.Action != "alive" {
		log.Printf("%+v\n", req)
	}

	if req.Action == "ping" {
		pingCheck(req.Param, req.UUID)
		result = "success"
	} else if req.Action == "head" {
		headCheck(req.Param, req.UUID)
		result = "success"
	} else if req.Action == "dns" {
		dnsCheck(req.Param, req.UUID)
		result = "success"
	} else if req.Action == "traceroute" {
		tracerouteCheck(req.Param, req.UUID)
		result = "success"
	} else if req.Action == "alive" {
		if !pongStarted.IsSet() {
			pongStarted.Set()

			req.ZondUUID = *zonduuid
			// js, _ := json.Marshal(req)

			//Post("http://"+*addr+"/zond/pong", string(js))

			pongStarted.UnSet()

			result = "success"
		}
	}
	return &proto.CallResponse{Status: result, PeerId: s.PeerID.Pretty()}, nil
}
